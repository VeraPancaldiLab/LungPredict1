---
title: "LP_early"
author: "Marcelo Hurtado"
date: "2023-05-24"
output: html_document
---

Load packages and functions
```{r}
source(paste0(getwd(),"/environment_set.R"))
libraries_set()
```

Datasets
```{r}
dataset = "LungPredict"
dataset = "Vanderbilt"
dataset = "LPVan"
```

Input files
```{r}
Counts_normalized <- as.matrix(read.csv(paste0(getwd(),"/Output/Counts_normalized_", dataset, ".csv"), row.names = 1))
clinical.data <- read.csv(paste0(getwd(),"/Input/ClinicalData/ClinicalData_", dataset, ".csv"), row.names = 1)
```

Match Vanderbilt and LP genes
```{r}
Counts_normalized_LP = data.frame(Counts_normalized)
Counts_normalized_Van = data.frame(Counts_normalized)

#Keep only gene names
m2 <- do.call(rbind, strsplit(rownames(Counts_normalized_LP), split="_", fixed = TRUE))
Counts_normalized_LP = as.matrix(Counts_normalized_LP)
rownames(Counts_normalized_LP) = m2[,2]

Counts_normalized_LP = Counts_normalized_LP[rownames(Counts_normalized_LP)%in%rownames(Counts_normalized_Van),]
Counts_normalized_Van = Counts_normalized_Van[rownames(Counts_normalized_Van)%in%rownames(Counts_normalized_LP),]
```

Keeping only early stage
```{r}
Counts_normalized = Counts_normalized_LP
clinical.data = clinical.data[-which(clinical.data$Stages_simplified%in%c("III", "IV")),]
Counts_normalized = Counts_normalized[,colnames(Counts_normalized)%in%rownames(clinical.data)]
```

Calculate TFs scores
```{r}
TFs = compute_TFs_scores(Counts_normalized, dataset)
```

Look for cell-by-cell groups
```{r}
dend_column = as.dendrogram(hclust(dist(scale(t(deconv_df))), method = "ward.D2"))
png(paste0(getwd(),"/Figures/Dendogram_patients_", dataset, ".png"), width = 3500, height = 1500, res=150)
par(mar = c(5, 5, 4, 15)) #bottom, left, top, right
plot(dend_column, horiz=T)
rect.dendrogram(dend_column, h=15,horiz=F)
dev.off()
```

TFs modules
```{r}
# Elbow method
fviz_nbclust(TFs, hcut, method = "wss") +
  labs(subtitle = "Elbow method")

# Silhouette method
x = fviz_nbclust(TFs, hcut, method = "silhouette")+
  labs(subtitle = "Silhouette method")

# Gap statistic
set.seed(123)
fviz_nbclust(TFs, hcut, nstart = 25,  method = "gap_stat", nboot = 1000)+
  labs(subtitle = "Gap statistic method")

x = NbClust(data = TFs, diss = NULL, distance = "euclidean",
        min.nc = 2, max.nc = 15, method = "ward.D2")

kmeans.samples <- kmeans(TFs, centers = 4, nstart = 20)
TFs$Cluster = kmeans.samples$cluster

hc1 = as.dendrogram(hclust(dist(TFs), method = "ward.D2"))
```
WGCNA
```{r}
###Input files
data = t(TFs) #--> rows samples and genes as columns
#coldata = deconv[1:nrow(deconv)-1,]
coldata = Deconvolution

###Choose Soft Threshold (power) parameter
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))
sft = pickSoftThreshold(data, powerVector = powers, verbose = 5)
print(plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
    xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
    main = paste("Scale independence")))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers,cex=0.9,col="red")
abline(h=0.90,col="red")

###Compute WGCNA modules
cor <- WGCNA::cor
picked_power = 10
netwk <- blockwiseModules(data,
                          power = picked_power,
                          networkType = "signed",
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          minModuleSize = 5,
                          reassignThreshold = 0,
                          mergeCutHeight = 0.15,
                          numericLabels = T,
                          verbose = 3)
mergedColors = labels2colors(netwk$colors)
module_df <- data.frame(gene_id = names(netwk$colors),
                        colors = paste0("ME", labels2colors(netwk$colors))) 

###Get Module eigengenes per cluster
nGenes = ncol(data)
nSamples = nrow(data)
MEs0 <- moduleEigengenes(data, mergedColors)$eigengenes
MEs0 <- orderMEs(MEs0)
hubgenes = chooseTopHubInEachModule(data, mergedColors)
module_order = names(MEs0) %>% gsub("ME","", .)
MEs0$treatment = row.names(MEs0)
MEs0$treatment = NULL  

###Merge TFs modules
height = 1 #Vanderbilt parameter
d <- dist(t(MEs0), method = "euclidean")
hc1 <- hclust(d, method = "ward.D2" )
vec = hc1[["order"]]
clusters <- cutree(hc1, h = height)
hc = as.dendrogram(hc1)
avg_col_dend <- color_branches(hc, h = height)
png(paste0(getwd(),"/Figures/WGCNA/Dendogram_Modules_TFs_", dataset, ".png"), width = 2500, height = 2500, res=150)
par(mar = c(5, 5, 4, 30)) #bottom, left, top, right
plot(avg_col_dend, horiz= T)
rect.dendrogram(avg_col_dend, h=height,horiz=TRUE)
dev.off()

```

```{r}
MEs0_merge = MEs0 %>%
  t() %>%
  as_tibble() %>%
  mutate("Cluster" = paste0("Cluster ", clusters)) %>%
  group_by(Cluster) %>%
  summarise(across(everything(), mean)) %>%
  column_to_rownames("Cluster")

####Save TFs of each module
data = MEs0 %>%
  t() %>%
  as_tibble() %>%
  mutate("Cluster" = clusters) %>%
  as.data.frame()

rownames(data) = colnames(MEs0)

modules_merged = list()
for (i in 1:nrow(MEs0_merge)) {
  idx = which(data$Cluster==i)
  modules_merged[[i]] = module_df$gene_id[module_df$colors%in%rownames(data)[idx]]
  names(modules_merged)[i] = paste0("Cluster ", i)
}
```

```{r}
library(devtools)
install_github("ProcessMiner/nlcor")
library(nlcor)
yy = nlcor(Deconvolution)

library(infotheo)
dat<-discretize(Deconvolution)
# Install and load the pracma package
install.packages("pracma")
library(pracma)

# Calculate mutual information matrix
num_vars <- ncol(Deconvolution)
mi_matrix <- matrix(0, nrow = num_vars, ncol = num_vars)
for (i in 1:num_vars) {
  for (j in 1:num_vars) {
    mi_matrix[i, j] <- entropy(dat[, i]) + entropy(dat[, j]) - entropy(dat[, c(i, j)])
  }
}

# Print the mutual information matrix
print(mi_matrix)
colnames(mi_matrix) = colnames(Deconvolution)
rownames(mi_matrix) = colnames(Deconvolution)

# Number of permutations
num_permutations <- 500

# Initialize matrix to store permuted mutual information values
permuted_mi_matrix <- matrix(0, nrow = num_vars, ncol = num_vars)

# Initialize data frame to store p-values
p_values_df <- data.frame(Var1 = character(), Var2 = character(), p_value = numeric(), stringsAsFactors = FALSE)

# Perform permutation test
for (perm in 1:num_permutations) {
  permuted_matrix <- dat[, sample(num_vars)]  # Randomly permute the columns
  for (i in 1:num_vars) {
    for (j in 1:num_vars) {
      permuted_mi <- entropy(permuted_matrix[, i]) + entropy(permuted_matrix[, j]) - entropy(permuted_matrix[, c(i, j)])
      permuted_mi_matrix[i, j] <- permuted_mi
    }
  }
  
  # Calculate p-values for each variable pair
  p_values <- rowMeans(permuted_mi_matrix >= mi_matrix)  # Adjusted for multiple comparisons
  
  # Add p-values to the data frame
  p_values_df <- rbind(p_values_df, data.frame(Var1 = rownames(mi_matrix), Var2 = colnames(mi_matrix), p_value = p_values))
}

#computes the MIM (mutual information matrix)
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat, diag = T)]<- NA
  return(cormat)
}
  
upper_tri <- get_upper_tri(data.frame(mi_matrix))
x = melt(upper_tri)
x = na.omit(x)
x = as.data.frame(lapply(x, as.character))
t = nlcor(Deconvolution[,1], Deconvolution[,27])
```

Relate results with features
```{r}
moduleTraitCor = cor(t(MEs0_merge), coldata, use = "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)

textMatrix =  paste(signif(moduleTraitCor, 2), "\n(",
                  signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
  
idx = which(moduleTraitPvalue>0.05)
for (i in idx) {
  textMatrix[i] = NA
}

d <- dist(t(moduleTraitCor), method = "euclidean")
hc1 <- hclust(d, method = "ward.D2" )
vec = hc1[["order"]]
  
###Figure module-trait relationship
png(paste0(getwd(),"/Figures/WGCNA/Module_trait_relationships_", dataset, ".png"), width = 3500, height = 1500, res=150)
par(mar = c(20, 10, 4, 4)) #bottom, left, top, right
labeledHeatmap(Matrix = moduleTraitCor[,vec],
               xLabels = names(coldata[,vec]),
               yLabels = rownames(MEs0_merge),
               ySymbols = rownames(MEs0_merge),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix[,vec],
               setStdMargins = FALSE,
               cex.text = 0.8,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
dev.off()

#Modules filtering 
#1. Remove high correlate modules
#2. Remove low correlated modules with features
#3. Remove modules that contains unconnected TFs
MEs0_merge = MEs0_merge[-which(rownames(MEs0_merge)%in%vec),]
```

Plot results
```{r}
ha = heatmap_annotation(clinical.data)
dend_column = dend_column = as.dendrogram(hclust(dist(scale(t(deconv_df))), method = "ward.D2"))

ht1 = Heatmap(t(scale(deconv_df)), 
        border = T, 
        top_annotation = ha,  clustering_distance_columns = "euclidean",
        name = "Deconvolution", 
        column_dend_height = unit(5, "cm"), row_dend_width = unit(2, "cm"), 
        column_dend_reorder = T, row_dend_reorder = F,
        show_row_names = T, 
        show_heatmap_legend = T, 
        row_names_gp = gpar(fontsize = 14), 
        column_names_gp = gpar(fontsize =12), 
        width = unit(20, "cm"), height = unit(10, "cm"),
        heatmap_legend_param = list(labels_gp = gpar(fontsize = 12), legend_width = unit(12, "cm"), 
                                    legend_heigh = unit(12, "cm"), title_gp = gpar(fontsize = 12)))

png(paste0(getwd(),"/Figures/test", dataset, ".png"), width = 4500, height = 3000, res=250)
draw(ht1, show_heatmap_legend = T, heatmap_legend_side = "left", annotation_legend_side = 'left')
dev.off()
```
